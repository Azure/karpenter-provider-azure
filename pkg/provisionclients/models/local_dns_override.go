/*
Portions Copyright (c) Microsoft Corporation.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LocalDNSOverride Overrides for localDNS profile.
//
// swagger:model LocalDNSOverride
type LocalDNSOverride struct {

	// Cache max TTL in seconds. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	CacheDurationInSeconds *int32 `json:"cacheDurationInSeconds,omitempty"`

	// Destination server for DNS queries to be forwarded from localDNS.
	// Enum: ["ClusterCoreDNS","VnetDNS"]
	ForwardDestination *string `json:"forwardDestination,omitempty"`

	// Forward policy for selecting upstream DNS server. See [forward plugin](https://coredns.io/plugins/forward) for more information.
	// Enum: ["Sequential","RoundRobin","Random"]
	ForwardPolicy *string `json:"forwardPolicy,omitempty"`

	// Maximum number of concurrent queries. See [forward plugin](https://coredns.io/plugins/forward) for more information.
	MaxConcurrent *int32 `json:"maxConcurrent,omitempty"`

	// Enforce TCP or prefer UDP protocol for connections from localDNS to upstream DNS server.
	// Enum: ["PreferUDP","ForceTCP"]
	Protocol *string `json:"protocol,omitempty"`

	// Log level for DNS queries in localDNS.
	// Enum: ["Error","Log"]
	QueryLogging *string `json:"queryLogging,omitempty"`

	// Policy for serving stale data. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	// Enum: ["Verify","Immediate","Disable"]
	ServeStale *string `json:"serveStale,omitempty"`

	// Serve stale duration in seconds. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	ServeStaleDurationInSeconds *int32 `json:"serveStaleDurationInSeconds,omitempty"`
}

// Validate validates this local DNS override
func (m *LocalDNSOverride) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForwardPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryLogging(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServeStale(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var localDnsOverrideTypeForwardDestinationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ClusterCoreDNS","VnetDNS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localDnsOverrideTypeForwardDestinationPropEnum = append(localDnsOverrideTypeForwardDestinationPropEnum, v)
	}
}

const (

	// LocalDNSOverrideForwardDestinationClusterCoreDNS captures enum value "ClusterCoreDNS"
	LocalDNSOverrideForwardDestinationClusterCoreDNS string = "ClusterCoreDNS"

	// LocalDNSOverrideForwardDestinationVnetDNS captures enum value "VnetDNS"
	LocalDNSOverrideForwardDestinationVnetDNS string = "VnetDNS"
)

// prop value enum
func (m *LocalDNSOverride) validateForwardDestinationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localDnsOverrideTypeForwardDestinationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalDNSOverride) validateForwardDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.ForwardDestination) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardDestinationEnum("forwardDestination", "body", *m.ForwardDestination); err != nil {
		return err
	}

	return nil
}

var localDnsOverrideTypeForwardPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Sequential","RoundRobin","Random"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localDnsOverrideTypeForwardPolicyPropEnum = append(localDnsOverrideTypeForwardPolicyPropEnum, v)
	}
}

const (

	// LocalDNSOverrideForwardPolicySequential captures enum value "Sequential"
	LocalDNSOverrideForwardPolicySequential string = "Sequential"

	// LocalDNSOverrideForwardPolicyRoundRobin captures enum value "RoundRobin"
	LocalDNSOverrideForwardPolicyRoundRobin string = "RoundRobin"

	// LocalDNSOverrideForwardPolicyRandom captures enum value "Random"
	LocalDNSOverrideForwardPolicyRandom string = "Random"
)

// prop value enum
func (m *LocalDNSOverride) validateForwardPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localDnsOverrideTypeForwardPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalDNSOverride) validateForwardPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ForwardPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardPolicyEnum("forwardPolicy", "body", *m.ForwardPolicy); err != nil {
		return err
	}

	return nil
}

var localDnsOverrideTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PreferUDP","ForceTCP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localDnsOverrideTypeProtocolPropEnum = append(localDnsOverrideTypeProtocolPropEnum, v)
	}
}

const (

	// LocalDNSOverrideProtocolPreferUDP captures enum value "PreferUDP"
	LocalDNSOverrideProtocolPreferUDP string = "PreferUDP"

	// LocalDNSOverrideProtocolForceTCP captures enum value "ForceTCP"
	LocalDNSOverrideProtocolForceTCP string = "ForceTCP"
)

// prop value enum
func (m *LocalDNSOverride) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localDnsOverrideTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalDNSOverride) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

var localDnsOverrideTypeQueryLoggingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Error","Log"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localDnsOverrideTypeQueryLoggingPropEnum = append(localDnsOverrideTypeQueryLoggingPropEnum, v)
	}
}

const (

	// LocalDNSOverrideQueryLoggingError captures enum value "Error"
	LocalDNSOverrideQueryLoggingError string = "Error"

	// LocalDNSOverrideQueryLoggingLog captures enum value "Log"
	LocalDNSOverrideQueryLoggingLog string = "Log"
)

// prop value enum
func (m *LocalDNSOverride) validateQueryLoggingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localDnsOverrideTypeQueryLoggingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalDNSOverride) validateQueryLogging(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryLogging) { // not required
		return nil
	}

	// value enum
	if err := m.validateQueryLoggingEnum("queryLogging", "body", *m.QueryLogging); err != nil {
		return err
	}

	return nil
}

var localDnsOverrideTypeServeStalePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Verify","Immediate","Disable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localDnsOverrideTypeServeStalePropEnum = append(localDnsOverrideTypeServeStalePropEnum, v)
	}
}

const (

	// LocalDNSOverrideServeStaleVerify captures enum value "Verify"
	LocalDNSOverrideServeStaleVerify string = "Verify"

	// LocalDNSOverrideServeStaleImmediate captures enum value "Immediate"
	LocalDNSOverrideServeStaleImmediate string = "Immediate"

	// LocalDNSOverrideServeStaleDisable captures enum value "Disable"
	LocalDNSOverrideServeStaleDisable string = "Disable"
)

// prop value enum
func (m *LocalDNSOverride) validateServeStaleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localDnsOverrideTypeServeStalePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalDNSOverride) validateServeStale(formats strfmt.Registry) error {
	if swag.IsZero(m.ServeStale) { // not required
		return nil
	}

	// value enum
	if err := m.validateServeStaleEnum("serveStale", "body", *m.ServeStale); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this local DNS override based on context it is used
func (m *LocalDNSOverride) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LocalDNSOverride) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalDNSOverride) UnmarshalBinary(b []byte) error {
	var res LocalDNSOverride
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
